/*************************************************************
 * 
 *  #####   ###   #     #    #		 #     #####    #####     ####
 *    #			 #    #	#	  #			#		#			 #  #	  	#		#		 #
 *    #			 #    #		# #				#				 ###			#####    #		
 *    #			###   #		  #				#				 #   #		#					####
 *
 * run_charon.cc
 * Generated by tinyrpc framework tinyrpc_generator.py
 * Create Time: 2022-11-13 21:56:10
 * This file will not be overwrite althrough protobuf file changed !!!
 * Just write this file while not exist
*************************************************************/


#include "tinyrpc/comm/log.h"
#include "tinyrpc/net/tinypb/tinypb_rpc_async_channel.h"
#include "tinyrpc/net/tinypb/tinypb_rpc_controller.h"
#include "tinyrpc/net/tinypb/tinypb_rpc_closure.h"
#include "charon/interface/run_charon.h"
#include "charon/pb/charon.pb.h"
#include "charon/comm/business_exception.h"
#include "charon/comm/errcode.h"
#include "charon/raft/raft_node.h"

namespace charon {

RunCharonInterface::RunCharonInterface(const ::RunCharonRequest& request, ::RunCharonResponse& response)
  : m_request(request), 
  m_response(response) {

}

RunCharonInterface::~RunCharonInterface() {

}

void RunCharonInterface::run() {
  //
  // Run your business at here
  // m_reponse.set_ret_code(0);
  // m_reponse.set_res_info("Succ");
  //

  checkInputParam();

  handle();

}


void RunCharonInterface::checkInputParam() {
  m_origin = m_request.origin();
  if (m_origin == EN_REQUEST_UNDEFINE) {
    throw BusinessException(ERR_PARAM_INPUT, "checkInputParam error, invalid request origin: " + std::to_string(m_origin), __FILE__, __LINE__); 
  }

}


void RunCharonInterface::handle() {
  if (m_origin == EN_REQUEST_FORM_CLIENT) {
    handleRequestFromClient();
  } else if (m_origin == EN_REQUEST_FORM_RAFTNODE) {
    handleRequestFromRaftNode();
  } else {
    throw BusinessException(ERR_PARAM_INPUT, "checkInputParam error, invalid request origin: " + std::to_string(m_origin), __FILE__, __LINE__); 
  }
}


//
// This function to deal request from outside client, such test_charon_client send a RunCharon cmd
// 
void RunCharonInterface::handleRequestFromClient() {

  AppDebugLog << "handleRequestFromClient begin";
  QueryAllRaftServerNodeRequest req;
  req.set_lstate(EN_RAFT_LSTATE_ACTIVE);
  std::vector<ServerNode> list;
  RaftNode::GetRaftNode()->queryAllRaftServerNode(req, list);

  if (list.empty()) {
    throw BusinessException(ERR_EMPTY_RAFTNODES, "raft server node list is empty!", __FILE__, __LINE__); 
  }

  if (list.size() == 1) {
    AppDebugLog << "Only set one raft node: " << RaftNode::RaftServerNodeToString(list[0]);
    return;
  }

  std::vector<tinyrpc::TinyPbRpcAsyncChannel::ptr> channels;

  for (auto& node : list) {
    if (node.id() == RaftNode::GetRaftNode()->getSelfNode().id()) {
      // skip self
      continue;
    }

    std::shared_ptr<RunCharonRequest> req = std::make_shared<RunCharonRequest>();
    std::shared_ptr<RunCharonResponse> rsp = std::make_shared<RunCharonResponse>();

    tinyrpc::IPAddress::ptr addr = std::make_shared<tinyrpc::IPAddress>(node.addr());
    tinyrpc::TinyPbRpcAsyncChannel::ptr rpc_channel = std::make_shared<tinyrpc::TinyPbRpcAsyncChannel>(addr);
    channels.push_back(rpc_channel);
    tinyrpc::TinyPbRpcController::ptr rpc_controller = std::make_shared<tinyrpc::TinyPbRpcController>();
    rpc_controller->SetTimeout(1000);

    req->set_set_node_id(node.id());
    req->set_origin(EN_REQUEST_FORM_RAFTNODE);
    *req->mutable_server_nodes() = {list.begin(), list.end()};
    rpc_channel->saveCallee(rpc_controller, req, rsp, nullptr);

    std::shared_ptr<CharonService_Stub> stub = std::make_shared<CharonService_Stub>(rpc_channel.get());

    stub->RunCharon(rpc_controller.get(), req.get(), rsp.get(), NULL);

  }

  for (auto& i : channels) {
    i->wait();

    RunCharonRequest* req = dynamic_cast<RunCharonRequest*>(i->getRequestPtr());
    RunCharonResponse* rsp = dynamic_cast<RunCharonResponse*>(i->getResponsePtr());
    if (req == nullptr || rsp == nullptr) {
      AppErrorLog << "system exception when call rpc";
      throw BusinessException(ERR_RPC_EXCEPTION, "system exception when call rpc", __FILE__, __LINE__); 
    }

    tinyrpc::TinyPbRpcController* controller = dynamic_cast<tinyrpc::TinyPbRpcController*>(i->getControllerPtr());
    if (controller== nullptr) {
      AppErrorLog << "system exception when call rpc";
      throw BusinessException(ERR_RPC_EXCEPTION, "system exception when call rpc", __FILE__, __LINE__); 
    }

    if (controller->ErrorCode() != 0) {
      throw BusinessException(ERR_RPC_EXCEPTION, formatString("call rpc error, error code=%d, errinfo=%s", controller->ErrorCode(), controller->ErrorText().c_str()), __FILE__, __LINE__); 
    }

    if (rsp->ret_code() != 0) {
      throw BusinessException(rsp->ret_code(), formatString("call RunCharon error, errcode=%d, errinfo=%s", rsp->ret_code(), rsp->res_info().c_str()), __FILE__, __LINE__); 
    }
  }
  // only all servers return OK, that means this raft run succ, and then some nodes has already begin to elecute

  // now directly start election
  charon::RaftNode::GetRaftNode()->getRaftPartition(0)->resetElectionTimer();

  AppDebugLog << "handleRequestFromClient end";
  return;
}

//
// This function to deal request from others raft server node, for sync raft node list info
//
void RunCharonInterface::handleRequestFromRaftNode() {

  AppDebugLog << "handleRequestFromRaftNode begin";
  std::vector<ServerNode> new_node_list;
  for (int i = 0; i < m_request.server_nodes_size(); ++i) {
    new_node_list.push_back(m_request.server_nodes().Get(i));
  }
  if (new_node_list.empty()) {
    throw BusinessException(ERR_PARAM_INPUT, "sync node list is empty", __FILE__, __LINE__);
  }

  RaftNode::GetRaftNode()->resetNodes(new_node_list);
  RaftNode::GetRaftNode()->setSelfId(m_request.set_node_id());

  startRaft();

  AppDebugLog << "handleRequestFromRaftNode end";
}


void RunCharonInterface::startRaft() {
  // 1. sleep random time
  // because other nodes maybe not init finished
  // sleep(1);

  AppDebugLog << "sleep end";
  // 2. start election
  charon::RaftNode::GetRaftNode()->getRaftPartition(0)->resetElectionTimer();

}

}