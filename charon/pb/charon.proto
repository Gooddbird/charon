syntax = "proto3";
option cc_generic_services = true;

message DiscoverTag {
  string tag1 = 1;
  string tag2 = 2;
  string tag3 = 3;
};

message DiscoverRequest {
  string server_name = 1;
  DiscoverTag tag = 2;
};

message DiscoverResponse {
  int32 ret_code = 1;
  string res_info = 2;
  string server_name = 3;
  DiscoverTag tag = 4;
  // ip:port
  string addr = 5;
  string ip = 6;
  int32 port = 7;
};

message RegisterRequest {
  string server_name = 1;
  string addr = 2;
  DiscoverTag tag = 3;
};

message RegisterResponse {
  int32 ret_code = 1;
  string res_info = 2;
};

enum AcceptResult {
  ACCEPT_UNKNOWN = 0;
  ACCEPT_SUCC = 1;
  ACCEPT_FAIL = 2;
};


enum RaftState {
  RAFT_UNKNOWN_STATE = 0;
  RAFT_FOLLOWER_STATE = 1;
  RAFT_CANDIDATE_STATE = 2;
  RAFT_LEADER_STATE = 3;
};

message LogEntry {
  int32 index = 1;
  int32 term = 2;
  string cmd = 3;
};

message AskVoteRequest {
  // the candidate's term
  int32 term = 1;

  // the candidate's id
  int32 id = 2;

  // the last log entry term of candidate
  int32 last_log_term = 3;

  // the last log entry index of candidate
  int32 last_log_index = 4;

  string name = 6;

  string addr = 7;

  int32 peer_id = 9;

};

message AskVoteResponse {
  int32 ret_code = 1;
  string res_info = 2;

  // current term
  int32 term = 3;

  // give a vote?
  AcceptResult accept_result = 4;
  // why not vote
  string vote_fail_reason = 5;

  int32 vote_fail_code = 6;

  int32 id = 7;

  string name = 8;

  string addr = 9;

  RaftState state = 11;
};

message AppendLogEntriesRequest {
  // the leader's term
  int32 leader_term = 1;
  // the leader's id
  int32 leader_id = 2;
  // the prev log' index of new log entries 
  int32 prev_log_index = 3;
  // the prev log' term of new log entries 
  int32 prev_log_term = 4;

  // the leader's max high commit log entry index
  int32 leader_commit_index = 5;

  repeated LogEntry log_entries = 6;

  int32 id = 7;

  string name = 8;

  string addr = 9;

  // last log index in log_enrties, if appendLog succ, use this value to help update nextIndex and matchIndex
  int32 last_log_index = 11;

  int32 peer_id = 12;
};

message AppendLogEntriesResponse {
  int32 ret_code = 1;
  string res_info = 2;

  // the follewer's term
  int32 term = 3;

  // append succ?
  AcceptResult accept_result = 4;
  // reason of append log why failed
  string append_fail_reason = 5;

  int32 append_fail_code = 6;

  int32 id = 7;

  string name = 8;

  string addr = 9;

  // if can't find match pre_log_index pre_log_term, return the last can match log's index and term
  int32 need_index = 11;
  int32 need_term = 12;

  RaftState state = 13;
};


service CharonService {
  // discover server addr
  rpc DiscoverServer(DiscoverRequest) returns (DiscoverResponse);

  // rpc method name
  rpc RegisterServer(RegisterRequest) returns (RegisterResponse);



  // RAFT
  // ask server to obtain a vote, to help become leader
  rpc AskVote(AskVoteRequest) returns (AskVoteResponse);

  // only leader call, to append log to other followers 
  rpc AppendLogEntries(AppendLogEntriesRequest) returns (AppendLogEntriesResponse);

}